入门
自 2.1.0 版本起

在本节中，我们将逐步为您提供一些示例。

ModularUI教程 1：在屏幕上创建和显示
我们先从一个简单的 UI 开始。`A`ModularUI充当 UI 的运行时管理器，负责处理所有已定义元素的生命周期、渲染和交互。它接受一个 `A`UI实例，还可以选择性地接受一个 `B`作为输入。更多详情Player请查看ModularUI 页面。


private static ModularUI createModularUI() {
// create a root element
var root = new UIElement();
root.addChildren(
// add a label to display text
new Label().setText("My First UI"),
// add a button with text
new Button().setText("Click Me!"),
// add an element to display an image based on a resource location
new UIElement().layout(layout -> layout.width(80).height(80))
.style(style -> style.background(
SpriteTexture.of("ldlib2:textures/gui/icon.png"))
)
).style(style -> style.background(Sprites.BORDER)); // set a background for the root element
// create a UI
var ui = UI.of(root);
// return a modular UI for runtime instance
return ModularUI.of(ui);
}
接下来，我们需要显示用户界面。与大多数强制使用专用屏幕类的用户界面库不同，LDLib2 提供了一个通用的解决方案，可以在您选择的任何屏幕中渲染和交互用户界面。这意味着您可以在屏幕初始化阶段ModularUI创建并初始化用户界面，如下所示。ModularUI


@OnlyIn(Dist.CLIENT)
public class MyScreen extends Screen {
// .....

    // initial
    @Override
    public void init() {
        super.init();
        var modularUI = createModularUI();
        modularUI.setScreenAndInit(this);
        this.addRenderableWidget(modularUI.getWidget());
    }

    // .....
}
快速测试

如果您不想处理代码screen和显示问题，我们也ModularUIScreen为您提供了相应的解决方案。请查看屏幕和菜单页面了解更多详情。


public static void openScreenUI() {
var modularUI = createModularUI();
minecraft.setScreen(new ModularUIScreen(modularUI, Component.empty()));
}
教程 1
教程 2：更好的布局和样式
没问题，它能运行——但布局和样式仍然不够理想。例如，我们想给根元素添加内边距，在组件之间添加一些间距，并将标签居中对齐。由于瑜伽课程的缘故，我们确实需要处理布局代码。请查看布局页面了解更多详情。让我们通过改进布局和样式来提升用户界面。


private static ModularUI createModularUI() {
// create a root element
var root = new UIElement();
root.addChildren(
// add a label to display text
new Label().setText("My First UI")
// center align text
.textStyle(textStyle -> textStyle.textAlignHorizontal(Horizontal.CENTER)),
// add a button with text
new Button().setText("Click Me!"),
// add an element to display an image based on a resource location
new UIElement().layout(layout -> layout.width(80).height(80))
.style(style -> style.background(
SpriteTexture.of("ldlib2:textures/gui/icon.png"))
)
).style(style -> style.background(Sprites.BORDER)); // set a background for the root element
// set padding and gap for children elements
root.layout(layout -> layout.paddingAll(7).gapAll(5));
// create a UI
var ui = UI.of(root);
// return a modular UI for runtime instance
return ModularUI.of(ui);
}
教程 2 结果
教程 3：组件交互和 UI 事件
我们来看看如何与组件交互。这里我们以按钮为例，按钮提供此功能。我们引入两个按钮，可以将图像旋转±45°。setOnClick()


private static ModularUI createModularUI() {
// create a root element
var root = new UIElement();
// add an element to display an image based on a resource location
var image = new UIElement().layout(layout -> layout.width(80).height(80))
.style(style -> style.background(
SpriteTexture.of("ldlib2:textures/gui/icon.png"))
);
root.addChildren(
// add a label to display text
new Label().setText("Interaction")
// center align text
.textStyle(textStyle -> textStyle.textAlignHorizontal(Horizontal.CENTER)),
image,
// add a container with the row flex direction
new UIElement().layout(layout -> layout.flexDirection(YogaFlexDirection.ROW)).addChildren(
// a button to rotate the image -45°
new Button().setText("-45°")
.setOnClick(e -> image.transform(transform ->
transform.rotation(transform.rotation()-45))),
new UIElement().layout(layout -> layout.flex(1)), // occupies the remaining space
// a button to rotate the image 45°
new Button().setText("+45°")
.setOnClick(e -> image.transform(transform ->
transform.rotation(transform.rotation() + 45)))
)
).style(style -> style.background(Sprites.BORDER)); // set a background for the root element
// set padding and gap for children elements
root.layout(layout -> layout.paddingAll(7).gapAll(5));
// create a UI
var ui = UI.of(root);
// return a modular UI for runtime instance
return ModularUI.of(ui);
}
教程 3 结果
在上一步中，我们使用了Button#setOnClick()处理交互的方式。虽然这种方式很方便，但它只是按钮组件提供的一种 API 方法。

LDLib2 本身提供了一个完整且灵活的 UI 事件系统。任何 UIElement 都可以监听输入事件，例如鼠标点击、悬停、命令、生命周期、拖拽、聚焦、键盘输入等等。更多详情请查看事件页面。

通过将基本的 UIElement 与事件监听器和样式相结合，您可以实现完全自定义的交互式组件，包括按钮。


private static ModularUI createModularUI() {
// create a root element
var root = new UIElement();
// add an element to display an image based on a resource location
var image = new UIElement().layout(layout -> layout.width(80).height(80))
.style(style -> style.background(
SpriteTexture.of("ldlib2:textures/gui/icon.png"))
);
root.addChildren(
// add a label to display text
new Label().setText("UI Event")
// center align text
.textStyle(textStyle -> textStyle.textAlignHorizontal(Horizontal.CENTER)),
image,
// add a container with the row flex direction
new UIElement().layout(layout -> layout.flexDirection(YogaFlexDirection.ROW)).addChildren(
// implement the button by using ui events
new UIElement().addChild(new Label().setText("-45°").textStyle(textStyle -> textStyle.adaptiveWidth(true)))
.layout(layout -> layout.justifyItems(YogaJustify.CENTER).paddingHorizontal(3))
.style(style -> style.background(Sprites.BORDER1))
.addEventListener(UIEvents.MOUSE_DOWN, e -> image.transform(transform ->
transform.rotation(transform.rotation()-45)))
.addEventListener(UIEvents.MOUSE_ENTER, e ->
e.currentElement.style(style -> style.background(Sprites.BORDER1_DARK)), true)
.addEventListener(UIEvents.MOUSE_LEAVE, e ->
e.currentElement.style(style -> style.background(Sprites.BORDER1)), true),
new UIElement().layout(layout -> layout.flex(1)), // occupies the remaining space
// a button to rotate the image 45°
new Button().setText("+45°")
.setOnClick(e -> image.transform(transform ->
transform.rotation(transform.rotation() + 45)))
)
).style(style -> style.background(Sprites.BORDER)); // set a background for the root element
// set padding and gap for children elements
root.layout(layout -> layout.paddingAll(7).gapAll(5));
// create a UI
var ui = UI.of(root);
// return a modular UI for runtime instance
return ModularUI.of(ui);
}
教程 5 结果
教程 4：用户界面样式表
在教程 2中，我们通过直接在代码中配置布局和样式来改进布局和视觉效果。虽然这种方法效果不错，但随着用户界面规模的扩大，内联布局和样式定义很快就会变得冗长且难以维护。

为了解决这个问题，LDLib2 引入了一个名为LSSLDLib2 StyleSheet（LSS）的样式表系统。LSS 允许您以声明式的、类似 CSS 的方式描述布局和样式属性，从而将视觉设计与 UI 结构分离。更多详情请查看样式表页面。

在以下示例中，我们使用 LSS 重新实现了步骤 3 中的布局和样式逻辑：

示例 1 演示了 LSS 绑定直接应用于 UI 元素。
示例 2 展示了如何定义一个独立的样式表并将其应用于用户界面。

例1

private static ModularUI createModularUI() {
var root = new UIElement();
root.addChildren(
new Label().setText("LSS example")
.lss("horizontal-align", "center"),
new Button().setText("Click Me!"),
new UIElement()
.lss("width", 80)
.lss("height", 80)
.lss("background", "sprite(ldlib2:textures/gui/icon.png)")
);
root.lss("background", "built-in(ui-gdp:BORDER)");
root.lss("padding-all", 7);
root.lss("gap-all", 5);
var ui = UI.of(root);
return ModularUI.of(ui);
}


例 2
private static ModularUI createModularUI() {
// set root with an ID
var root = new UIElement().setId("root");
root.addChildren(
new Label().setText("LSS example"),
new Button().setText("Click Me!"),
// set the element with a class
new UIElement().addClass("image")
);
var lss = """
// id selector
#root {
background: built-in(ui-gdp:BORDER);
padding-all: 7;
gap-all: 5;
}

        // class selector
        .image {
            width: 80;
            height: 80;
            background: sprite(ldlib2:textures/gui/icon.png);
        }

        // element selector
        #root label {
            horizontal-align: center;
        }
        """;
    var stylesheet = Stylesheet.parse(lss);
    // add stylesheets to ui
    var ui = UI.of(root, stylesheet);
    return ModularUI.of(ui);
}

内置样式表

除了自定义 LSS 定义外，LDLib2 还提供了几个内置样式表主题，涵盖了大多数常见的 UI 组件：

StylesheetManager.GDP
StylesheetManager.MC
StylesheetManager.MODERN
这些内置样式表让您只需极少的设置即可为整个用户界面应用一致的视觉风格。您可以通过 `<stylesheet_packs>` 访问和管理它们StylesheetManager，`<stylesheet_packs>` 充当所有可用样式表包的中央注册表。

private static ModularUI createModularUI() {
var root = new UIElement();
root.layout(layout -> layout.width(100));
root.addChildren(
new Label().setText("Stylesheets"),
new Button().setText("Click Me!"),
new ProgressBar().setProgress(0.5f).label(label -> label.setText("Progress")),
new Toggle().setText("Toggle"),
new TextField().setText("Text Field"),
new UIElement().layout(layout -> layout.setFlexDirection(YogaFlexDirection.ROW)).addChildren(
new ItemSlot().setItem(Items.APPLE.getDefaultInstance()),
new FluidSlot().setFluid(new FluidStack(Fluids.WATER, 1000))
),
// list all stylesheets
new Selector<ResourceLocation>()
.setSelected(StylesheetManager.GDP, false)
.setCandidates(StylesheetManager.INSTANCE.getAllPackStylesheets().stream().toList())
.setOnValueChanged(selected -> {
// switch to the selected stylesheet
var mui = root.getModularUI();
if (mui != null) {
mui.getStyleEngine().clearAllStylesheets();
mui.getStyleEngine().addStylesheet(StylesheetManager.INSTANCE.getStylesheetSafe(selected));
}
})
);
root.addClass("panel_bg");
// use GDP stylesheets by default
var ui = UI.of(root, StylesheetManager.INSTANCE.getStylesheetSafe(StylesheetManager.GDP)));
return ModularUI.of(ui);
}
教程 4 结果
教程5：数据绑定
LDLib2 为大多数数据驱动的 UI 组件提供内置的数据绑定支持。这使得 UI 元素能够与底层数据保持同步，而无需手动更新逻辑。该绑定系统基于和。有关更多详细信息，请参阅数据绑定页面。IObserver<T>IDataProvider<T>

在这个例子中：

共享的原子整数充当唯一的真理来源。
按钮直接修改值
TextField 通过观察者更新值
当数据发生变化时，标签和进度条会自动刷新。

private static ModularUI createModularUI() {
// a value holder
var valueHolder = new AtomicInteger(0);

    var root = new UIElement();
    root.addChildren(
            new Label().setText("Data Bindings")
                    .textStyle(textStyle -> textStyle.textAlignHorizontal(Horizontal.CENTER)),
            new UIElement().layout(layout -> layout.flexDirection(YogaFlexDirection.ROW)).addChildren(
                    // button to decrease the value
                    new Button().setText("-")
                            .setOnClick(e -> {
                                if (valueHolder.get() > 0) {
                                    valueHolder.decrementAndGet();
                                }
                            }),
                    new TextField()
                            .setNumbersOnlyInt(0, 100)
                            .setValue(String.valueOf(valueHolder.get()))
                            // bind an Observer to update the value holder
                            .bindObserver(value -> valueHolder.set(Integer.parseInt(value)))
                            // bind a DataSource to notify the value changes
                            .bindDataSource(SupplierDataSource.of(() -> String.valueOf(valueHolder.get())))
                            .layout(layout -> layout.flex(1)),
                    // button to increase the value
                    new Button().setText("+")
                            .setOnClick(e -> {
                                if (valueHolder.get() < 100) {
                                    valueHolder.incrementAndGet();
                                }
                            })
            ),
            // bind a DataSource to notify the value changes for label and progress bar
            new Label().bindDataSource(SupplierDataSource.of(() -> Component.literal("Binding: ").append(String.valueOf(valueHolder.get())))),
            new ProgressBar()
                    .setProgress(valueHolder.get() / 100f)
                    .bindDataSource(SupplierDataSource.of(() -> valueHolder.get() / 100f))
                    .label(label -> label.bindDataSource(SupplierDataSource.of(() -> Component.literal("Progress: ").append(String.valueOf(valueHolder.get())))))
    ).style(style -> style.background(Sprites.BORDER));
    root.layout(layout -> layout.width(100).paddingAll(7).gapAll(5));
    return ModularUI.of(UI.of(root));
}
教程 5 结果
教程 6：ModularUI菜单
在之前的教程中，我们主要关注　ModularUI客户端屏幕内的渲染。这种方法适用于纯视觉或仅限客户端的界面。

然而，Minecraft 中的大多数真实世界图形用户界面 (GUI) 都是服务器-客户端同步的。当 GUI 涉及游戏逻辑或持久化数据时，服务器必须保持权威性。在原版 Minecraft 中，这是通过一个同步机制来实现的Menu，该机制负责管理服务器和客户端之间的同步。

与仅支持客户端渲染的 UI 库不同，LDLib2 为服务器端菜单提供了一流的支持。您可以ModularUI直接将其与菜单一起使用，无需额外的网络或同步代码。

让我们创建一个简单的基于菜单的用户界面，用于显示玩家的物品栏。


private static ModularUI createModularUI(Player player) {
var root = new UIElement();
root.addChildren(
new Label().setText("Menu UI"),
// add player invotry
new InventorySlots()
).addClass("panel_bg");

    var ui = UI.of(root, StylesheetManager.INSTANCE.getStylesheetSafe(StylesheetManager.GDP));
    // pass the player to the Modular UI
    return ModularUI.of(ui, player);
}
您需要创建一个ModularUI带有 `<T>` 的 `<T>` Player，这是基于菜单的 UI 所必需的。此外，不仅是屏幕，您还应该初始化 ` ModularUI<T>` 的`<T> Menu`：

初始化应该在创建之后、写入额外数据缓冲区之前完成。
如有需要，请记得设置屏幕的正确图像尺寸。

public class MyContainerMenu extends AbstractContainerMenu {
// you can do initialization in the constructor
public MyContainerMenu(...) {
super(...)

        var modularUI = createModularUI(player)
        // we have added mixin to make the AbstractContainerMenu implementing the interface
        if (this instanceof IModularUIHolderMenu holder) {
            holder.setModularUI(modularUI);
        }
    }

    // .....
}

public class MyContainerScreen extends AbstractContainerScreen<MyContainerMenu> {
@Override
public void init() {
// the modular widget has already added + init by events
this.imageWidth = (int) getMenu().getModularUI().getWidth();
this.imageHeight = (int) getMenu().getModularUI().getHeight();
super.init();
}

    // .....
}
快速测试

要使用和打开基于菜单的用户界面，您需要注册自己的菜单项MenuType。LDLib2 也提供了相应的工具ModularUIContainerScreen来ModularUIContainerMenu帮助您快速完成设置。更多详情请查看屏幕截图和菜单页面。

或者，您可以使用提供的工厂快速上手。它们允许您以最少的设置创建基于菜单的方块、物品或玩家用户界面，无需手动注册或编写样板代码。在本例中，我们使用工厂进行PlayerUIMenuType快速演示。


public static final ResourceLocation UI_ID = LDLib2.id("unique_id");

// register your ui somewhere, e.g. during your mod initialization.
public static void registerPlayerUI() {
PlayerUIMenuType.register(UI_ID, ignored -> player -> createModularUI(player));
}

public static void openMenuUI(Player player) {
PlayerUIMenuType.openUI(player, UI_ID);
}
教程 6 结果
教程 7：屏幕与菜单之间的通信
虽然这些组件InventorySlots开箱即用，但它们是预先打包的内置组件。在实际项目中，您通常需要更好地控制客户端屏幕和服务器端菜单之间的数据和事件流。

data bindingsModularUI 提供对客户端和服务端的全面支持event dispatch。这使得客户端的 UI 交互能够安全地触发服务端的逻辑，并且服务端的状态更改能够自动更新 UI。更多详情请查看数据绑定页面。

在这里，我们着重介绍实用模式，帮助您快速入门。


// represents data on the server
private final ItemStackHandler itemHandler = new ItemStackHandler(2);
private final FluidTank fluidTank = new FluidTank(2000);
private boolean bool = true;
private String string = "hello";
private float number = 0.5f;

private static ModularUI createModularUI(Player player) {
// create a root element
var root = new UIElement();
root.addChildren(
// add a label to display text
new Label().setText("Data Between Screen and Menu"),
// bind storage to slots
new UIElement().addChildren(
new ItemSlot().bind(itemHandler, 0),
new ItemSlot().bind(new ItemHandlerSlot(itemHandler, 1).setCanTake(p -> false)),
new FluidSlot().bind(fluidTank, 0)
).layout(l -> l.gapAll(2).flexDirection(YogaFlexDirection.ROW)),
// bind value to the components
new UIElement().addChildren(
new Switch().bind(DataBindingBuilder.bool(() -> bool, value -> bool = value).build()),
new TextField().bind(DataBindingBuilder.string(() -> string, value -> string = value).build()),
new Scroller.Horizontal().bind(DataBindingBuilder.floatVal(() -> number, value -> number = value).build()),
// read-only (s->c), always get data from the server and display on the client
new Label().bind(DataBindingBuilder.componentS2C(() -> Component.literal("s->c only: ")
.append(Component.literal(String.valueOf(bool)).withStyle(ChatFormatting.AQUA)).append(" ")
.append(Component.literal(string).withStyle(ChatFormatting.RED)).append(" ")
.append(Component.literal("%.2f".formatted(number)).withStyle(ChatFormatting.YELLOW)))
.build())
).layout(l -> l.gapAll(2)),
// trigger ui events on the server side
new Button().addServerEventListener(UIEvents.MOUSE_DOWN, e -> {
if (fluidTank.getFluid().getFluid() == Fluids.WATER) {
fluidTank.setFluid(new FluidStack(Fluids.LAVA, 1000));
} else {
fluidTank.setFluid(new FluidStack(Fluids.WATER, 1000));
}
}),
// you could also use button.setOnServerClick(e -> { ... })
new InventorySlots()
);
root.addClass("panel_bg");

    // pass the player to the Modular UI
    return ModularUI.of(UI.of(root, StylesheetManager.INSTANCE.getStylesheetSafe(StylesheetManager.MODERN)), player);
}
教程 7 结果