#version 430

layout(local_size_x = 256) in;

struct Vertex {
    vec3 position;
    vec4 color;
    float lifeTime;
    float width;
};

layout(std430, binding = 0) buffer InputVertices {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer OutputVertices {
    Vertex smoothVertices[];
};

layout(binding = 2, offset = 0) uniform atomic_uint outputCount; // 用于记录输出顶点数量

uniform int inputCount;  // 传入的输入顶点数量
uniform float minDistance;

void main() {
    uint id = gl_GlobalInvocationID.x;  // 获取全局工作项的ID

    // 只处理有效的顶点索引
    if (id >= inputCount - 1) return;

    Vertex current = vertices[id];
    Vertex next = vertices[id + 1];

    vec3 p0 = vertices[max(int(id) - 1, 0)].position;
    vec3 p1 = current.position;
    vec3 p2 = next.position;
    vec3 p3 = vertices[min(int(id) + 2, inputCount - 1)].position;

    float distance = length(p2 - p1);

    // 插值生成新顶点
    if (distance > minDistance) {
        int steps = int(distance / minDistance);
        for (int j = 1; j <= steps; j++) {
            float t = float(j) / float(steps);
            vec3 interpolated = 0.5 * (
            (2.0 * p1) +
            (-p0 + p2) * t +
            (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t * t +
            (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t * t * t
            );

            // 原子操作增加输出数量，并写入插值顶点
            uint idx = atomicCounterIncrement(outputCount);
            smoothVertices[idx].position = interpolated;
            smoothVertices[idx].color = mix(current.color, next.color, t);
            smoothVertices[idx].lifeTime = mix(current.lifeTime, next.lifeTime, t);
            smoothVertices[idx].width = mix(current.width, next.width, t);
        }
    }
}
